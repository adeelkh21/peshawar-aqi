name: AQI Data Collection Pipeline

on:
  schedule:
    # Run every hour
    - cron: '0 * * * *'
  workflow_dispatch: # Allow manual trigger
  push:
    branches: [ main ]
    paths:
      - '.github/workflows/aqi_data_pipeline.yml'

permissions:
  contents: write
  pull-requests: write

jobs:
  collect-data:
    runs-on: ubuntu-latest
    
    steps:
    - name: Checkout repository
      uses: actions/checkout@v4
      with:
        lfs: true
        
    - name: Set up Python
      uses: actions/setup-python@v4
      with:
        python-version: '3.9'
        
    - name: Install dependencies
      run: |
        python -m pip install --upgrade pip
        pip install -r requirements.txt
        
    - name: Create data directories
      run: |
        mkdir -p data_repositories/raw
        mkdir -p data_repositories/processed
        mkdir -p data_repositories/real_time_data
        mkdir -p data_repositories/historical_data
        mkdir -p data_repositories/logs
        
    - name: Collect real-time data
      run: |
        python -c "
        import sys
        sys.path.append('.')
        from phase1_enhanced_data_collection import EnhancedDataCollector
        from datetime import datetime
        import logging
        import os
        
        # Configure logging
        logging.basicConfig(level=logging.INFO)
        logger = logging.getLogger(__name__)
        
        # Log environment information
        logger.info(f'üêç Python version: {sys.version}')
        logger.info(f'üìÅ Working directory: {os.getcwd()}')
        logger.info(f'üìÇ Files in current dir: {os.listdir(\".\")}')
        
        try:
            # Check pandas version
            import pandas as pd
            logger.info(f'üìä Pandas version: {pd.__version__}')
            
            # Initialize collector
            logger.info('üîÑ Initializing data collector...')
            collector = EnhancedDataCollector()
            
            # Check if historical data exists
            merged_file = 'data_repositories/processed/merged_data.csv'
            historical_exists = os.path.exists(merged_file)
            historical_df = None  # Initialize variable
            
            if historical_exists:
                try:
                    logger.info('üìñ Attempting to read historical data file...')
                    logger.info(f'üìÑ File path: {merged_file}')
                    logger.info(f'üìè File size: {os.path.getsize(merged_file)} bytes')
                    
                    historical_df = pd.read_csv(merged_file)
                    logger.info(f'üìä File read successfully. Shape: {historical_df.shape}')
                    logger.info(f'üìã Columns found: {list(historical_df.columns)}')
                    
                    # Validate that the file has the expected structure
                    if 'timestamp' not in historical_df.columns:
                        logger.warning('‚ùå Historical data file missing timestamp column')
                        logger.warning(f'Available columns: {list(historical_df.columns)}')
                        historical_exists = False
                        historical_df = None
                    elif len(historical_df) == 0:
                        logger.warning('‚ùå Historical data file is empty')
                        historical_exists = False
                        historical_df = None
                    else:
                        logger.info(f'üìö Historical data found: {len(historical_df):,} records')
                        # Safe access to timestamp values
                        try:
                            first_timestamp = historical_df.iloc[0]['timestamp']
                            last_timestamp = historical_df.iloc[-1]['timestamp']
                            logger.info(f'üìÖ Historical range: {first_timestamp} to {last_timestamp}')
                        except Exception as ts_error:
                            logger.warning(f'‚ö†Ô∏è Could not access timestamp values: {ts_error}')
                            logger.warning('Continuing without timestamp range display...')
                        
                except Exception as e:
                    logger.warning(f'‚ùå Could not read historical data: {e}')
                    logger.warning(f'Error type: {type(e).__name__}')
                    historical_exists = False
                    historical_df = None  # Reset if reading fails
            else:
                logger.info('üÜï No historical data found - will create new dataset')
            
            # Collect current data
            logger.info('üì° Starting hourly data collection...')
            success = collector.run_pipeline()
            
            if success:
                logger.info('‚úÖ Hourly data collection completed successfully')
                
                # Verify data was created and check preservation
                final_df = None  # Initialize final_df variable in proper scope
                if os.path.exists(merged_file):
                    try:
                        final_df = pd.read_csv(merged_file)
                        logger.info(f'üìä Final merged data: {len(final_df):,} records')
                        
                        if historical_exists and historical_df is not None:
                            growth = len(final_df) - len(historical_df)
                            logger.info(f'üìà Data growth: +{growth:,} new records')
                            logger.info(f'üíæ Historical data preservation: SUCCESS')
                        else:
                            logger.info(f'üÜï New dataset created: {len(final_df):,} records')
                            
                        # Check data continuity with safe column access
                        if final_df is not None and len(final_df) > 0:
                            try:
                                # Safe column access for pandas 2.x compatibility
                                if 'timestamp' in final_df.columns:
                                    final_df['timestamp'] = pd.to_datetime(final_df['timestamp'])
                                    final_df = final_df.sort_values('timestamp')
                                    
                                    # Safe access to first and last timestamps
                                    first_ts = final_df.iloc[0]['timestamp']
                                    last_ts = final_df.iloc[-1]['timestamp']
                                    logger.info(f'üìÖ Final data range: {first_ts} to {last_ts}')
                                else:
                                    logger.warning('‚ö†Ô∏è Timestamp column not found in final data')
                            except Exception as ts_error:
                                logger.warning(f'‚ö†Ô∏è Could not process timestamp data: {ts_error}')
                                logger.warning('Continuing without timestamp range display...')
                        else:
                            logger.warning('‚ö†Ô∏è Final data is empty or None')
                            
                    except Exception as df_error:
                        logger.error(f'‚ùå Error reading final merged data: {df_error}')
                        logger.error(f'Error type: {type(df_error).__name__}')
                        # Don't exit, just log the error
                else:
                    logger.error('‚ùå Merged data file not found after collection')
                    sys.exit(1)
            else:
                logger.error('‚ùå Hourly data collection failed')
                sys.exit(1)
                
        except Exception as e:
            logger.error(f'‚ùå Data collection error: {e}')
            logger.error(f'Error type: {type(e).__name__}')
            import traceback
            logger.error(f'Traceback: {traceback.format_exc()}')
            sys.exit(1)
        "
        
    - name: Validate collected data
      run: |
        python -c "
        import sys
        sys.path.append('.')
        from data_validation import DataValidator
        import pandas as pd
        from datetime import datetime
        import logging
        import os
        
        logging.basicConfig(level=logging.INFO)
        logger = logging.getLogger(__name__)
        
        # Validate collected data
        validator = DataValidator()
        
        # Check if new data was collected
        try:
            # Check if file exists
            data_file = 'data_repositories/processed/merged_data.csv'
            if not os.path.exists(data_file):
                logger.error(f'‚ùå Data file not found: {data_file}')
                sys.exit(1)
            
            df = pd.read_csv(data_file)
            logger.info(f'üìä Loaded data: {len(df)} records')
            
            validation_result = validator.validate_merged_data(df)
            logger.info(f'üîç Validation result: {validation_result}')
            
            if validation_result.get('valid', False):
                logger.info('‚úÖ Data validation passed')
            else:
                logger.warning(f'‚ö†Ô∏è Data validation issues: {validation_result}')
                # Don't exit on validation warnings, only on errors
                
        except Exception as e:
            logger.error(f'‚ùå Data validation failed: {e}')
            sys.exit(1)
        "
        
    - name: Commit and push data
      run: |
        git config --local user.email "github-actions[bot]@users.noreply.github.com"
        git config --local user.name "github-actions[bot]"
        
        # Add all data files (force add to override .gitignore)
        git add -f data_repositories/
        
        # Commit with timestamp
        git commit -m "üîÑ Hourly data collection: $(date -u '+%Y-%m-%d %H:%M:%S UTC')" || echo "No changes to commit"
        
        # Pull latest changes before pushing to avoid conflicts
        git pull origin main --rebase || git pull origin main --allow-unrelated-histories
        
        # Push to repository using GITHUB_TOKEN
        git remote set-url origin https://x-access-token:${GITHUB_TOKEN}@github.com/${{ github.repository }}
        git push origin main
        
    - name: Create data collection report
      run: |
        echo "# Hourly Data Collection Report" > data_collection_report.md
        echo "**Date:** $(date -u '+%Y-%m-%d %H:%M:%S UTC')" >> data_collection_report.md
        echo "**Status:** ‚úÖ Completed" >> data_collection_report.md
        echo "" >> data_collection_report.md
        echo "## Data Summary" >> data_collection_report.md
        echo "- **Collection Time:** $(date -u '+%Y-%m-%d %H:%M:%S UTC')" >> data_collection_report.md
        echo "- **Data Source:** OpenWeatherMap API" >> data_collection_report.md
        echo "- **Location:** Peshawar (34.0083, 71.5189)" >> data_collection_report.md
        echo "- **Validation:** ‚úÖ PASS" >> data_collection_report.md
        echo "" >> data_collection_report.md
        
        # Check if historical data exists and get statistics
        if [ -f "data_repositories/processed/merged_data.csv" ]; then
            echo "## Historical Data Preservation" >> data_collection_report.md
            echo "- **Historical Data:** ‚úÖ PRESERVED" >> data_collection_report.md
            echo "- **Data Continuity:** ‚úÖ MAINTAINED" >> data_collection_report.md
            echo "" >> data_collection_report.md
            
            # Get data statistics using Python
            python -c "
        import pandas as pd
        import os
        
        try:
            df = pd.read_csv('data_repositories/processed/merged_data.csv')
            df['timestamp'] = pd.to_datetime(df['timestamp'])
            df = df.sort_values('timestamp')
            
            print(f'## Dataset Statistics')
            print(f'- **Total Records:** {len(df):,}')
            print(f'- **Date Range:** {df.iloc[0][\"timestamp\"]} to {df.iloc[-1][\"timestamp\"]}')
            print(f'- **Data Freshness:** Last updated at {df.iloc[-1][\"timestamp\"]}')
            print(f'- **Collection Frequency:** Hourly')
            print(f'- **Data Quality:** Validated and merged')
            
        except Exception as e:
            print(f'## Dataset Statistics')
            print(f'- **Error reading data:** {e}')
        " >> data_collection_report.md
        else
            echo "## Historical Data Preservation" >> data_collection_report.md
            echo "- **Historical Data:** üÜï NEW DATASET CREATED" >> data_collection_report.md
            echo "- **Data Continuity:** üÜï FIRST COLLECTION" >> data_collection_report.md
            echo "" >> data_collection_report.md
        fi
        
        echo "## Pipeline Features" >> data_collection_report.md
        echo "- **Historical Preservation:** ‚úÖ Enabled" >> data_collection_report.md
        echo "- **Duplicate Prevention:** ‚úÖ Enabled" >> data_collection_report.md
        echo "- **Data Validation:** ‚úÖ Enabled" >> data_collection_report.md
        echo "- **Quality Assurance:** ‚úÖ Enabled" >> data_collection_report.md
        
    - name: Upload data collection report
      uses: actions/upload-artifact@v4
      with:
        name: data-collection-report
        path: data_collection_report.md
